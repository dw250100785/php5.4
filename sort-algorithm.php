<?php
/** 算法比较
 *  一般评判排序算法的标准有三个方面:
 *  1) 时间代价     效率
 *  2) 空间代价     开辟额外空间的代价
 *  3) 稳定性       对比较对象值相同的情况，排序后的相对位置是否保持原来顺序
 *  
 *  常见的排序算法大致分为四种:
 *  1) 插入排序 : 直接插入排序、 Shell排序
 *  2) 选择排序 : 直接选择排序、 堆排序
 *  3) 交换排序 : 冒泡排序、 快速排序
 *  4) 归并排序 : 合并排序
 *  
 *  而对排序算法的一般评判标准有:
 *  时间代价 : 比较次数、移动次数
 *  空间代价 : 额外空间、堆栈深度
 *  稳定性   : 存在多个具有相同排序码记录排序后这些记录的相对次序保持不变
 *  
 *  算法            最大时间          平均时间        最小时间       辅助空间        稳定性
 *  直接插入排序    0(n^2)            O(n^2)          O(n)           O(1)            稳定
 *  Shell排序       O(n^3/2)          O(n^3/2)        O(n^3/2)       O(1)            不稳定
 *  直接选择排序    O(n^2)            O(n^2)          O(n^2)         O(1)            不稳定
 *  堆排序          O(nlogn)          O(nlogn)        O(n^2)         O(1)            不稳定
 *  冒泡排序        O(n^2)            O(n^2)          O(n)           O(1)            稳定
 *  快速排序        O(n^2)            O(nlogn)        O(n)           O(logn)         不稳定
 *  归并排序        O(nlogn)          O(nlogn)        O(nlogn)       O(n)            稳定
 *
 *  从上述表中可以看到堆排序、快速排序和归并排序的时间代价是比较小的， 而其他几个的时间代价相对比较大。我们知道时间复杂度是评判一个算法的最主要标准。 程序运行速度速度直接关系着算法的可行性。 而真正美妙的算法也必定是运行速度比较快的。然而，由于现在计算机硬件的发展，尤其是多机缓存的引入， 导致堆排序在实际运行中并不快。 而且堆排序算法相对比较难理解， 程序实现也相对困难， 这样的算法显然不是美妙的算法。(备注: 仔细研读算法导论，其实堆排序还是蛮有意思的，不过堆还有更加适合的应用场景)。 至少在快速排序面前很难找到优势。
 *
 *
 *  下面对快速排序和合并排序(归并排序)做个详细对比和介绍
 *  快速排序:
 *  原理: 找一个主元(pivot element基元), 用该元素将要排序的数组分割成两组
 *        小的放在主元前面，大的放在主元后面
 *        然后对分割的子数组递归迭代上述操作
 *  伪代码:
 *  QUICK-SORT(A, p, r)
 *      if p < r 
 *          then q = PARTITION(A, p, r)
 *              QUICK-SORT(A, p, q-1)
 *              QUICK-SORT(A, q+1, r)
 *  其中PARTITION(A, p, r)对子数组A[p..r]进行就地重排，并返回主元最后的位置
 *  PARTITION(A, p, r)
 *      x = A[r]       //这里可以做几种特定优化，在后面介绍
 *      i = p - 1      //分割方法需要两个指针，这里是其中一个i,后面一个j在for循环中给出
 *      for(j = p; j < r; j++)
 *          do if A[j] <= x
 *              then i = i + 1                //i指针右移一位
 *              exchange(A[j], A[i])          //交换当前i, j指向元素的值
 *
 *      exchange(A[i+1], A[r])             //循环完后，将主元放在中间位置，即大元素区的第一个位置
 *      return i+1
 *  上面是分区的方法，但对于特殊情况存在一些效率低下的问题:
 *  1) 有序数组排序, 对于升序数组进行升序排列, 那么需要循环和移动的次数非常多，效率相对低下
 *  2) 对于数组较短的情况下，使用快速排序也不是最快的
 *
 *  那么为了应对上述的问题，下面有几种解决方案:
 *  1) 随机化改进: 不选择第一个元素作为基准，而是随机选择
 *  2) 平衡化改进: 取第一个、最后一个和中间点三个值的中间值为基准进行排序
 *  3) 设置阀值: 混合排序，当数组长度小于某一值的时候使用其他较快的排序方法实现
 *  对于算法分析这里省略， 可参见具体的文档
 *
 *  评价:
 *  快速排序的时间代价比较低，空间代价也比较低，算是时空代价相当好的算法。
 *  而且在下面的数值试验中也会发现，快速排序效率还是很好的。但是最大的不足使快速排序不稳定。
 *  比如在excel中进行排序，我们自然希望排序结果是稳定的（即相同的数排序后与原来的顺序相同）。
 *
 *  合并排序(归并排序)
 *  原理:
 *  1) 分解: 将n个元素分成各含n/2个元素的子序列
 *  2) 解决: 用合并排序法对两个子序列递归地排序
 *  3) 合并: 合并两个已排序的子序列以得到排序结果
 *  MERGE-SORT(A, p, r)
 *      if p < r
 *          then q = ceil((p + r) / 2)           //分两段
 *              MERGE-SORT(A, p, q)              //对左子数组递归合并算法
 *              MERGE-SORT(A, q+1, r)            //对右子数组递归合并算法
 *              MERGE(A, p, q, r)                //合并两个排序好的子数组
 *
 *  合并过程
 *  MERGE(A, p, q, r)
 *      n1 = q - p + 1;           //n1指向左子数组的第一个元素
 *      n2 = r-q                  //n2指向右子数组的第一个元素
 *      create arrays L[1..n1+1] and R[1..n2+1]       //建两个辅助数组，用于保存左右子数组
 *      for(i = 1; i <= n1; i++)
 *          do L[i] = A[p+i-1]                      //暂存左子数组的元素
 *      for(j = 1; j <= n2; j++)
 *          do R[j] = A[q+j]                        //暂存右子数组的元素
 *      // 这里做了个占位元素，无穷大， 有了这个占位元素就无需考虑是左子数组先遍历完还是右子数组先遍历
 *      // 如果不使用这个哨兵元素， 那么需要对未遍历完的子数组进行剩余元素的遍历
 *      L[n1 + 1] = 999999999999999999              //左子数组结束元素, 无穷大
 *      R[n2 + 1] = 999999999999999999              //右子数组结束元素, 无穷大
 *      // 重新初始化i, j到各自数组的开始位置
 *      i = 1
 *      j = 1
 *      for(k = p; k <= r; k++)
 *          do if L[i] <= R[j]                      //左子数组的i元素小于等于右数组的j元素
 *              then A[k] = L[i]
 *              i++
 *             else 
 *              A[k] = R[j]
 *              j++
 *  评价:
 *  归并排序时间代价是比较理想的，而且算法是稳定的，这个是很好的。但是不足的是排序的空间代价比较大，需要开一个与原数组同样大小的数组
 *
 *  总结:
 *  空间代价: 
        快速排序的空间代价为堆栈的深度， 但快排最坏的情况，堆栈的深度为n， 最好情况为log(n)，平均情况为O(log(n)).
 *      归并排序堆栈深度为O(log(n))， 但还需要额外的大小为n的空间，所以空间代价为O(n).
 *      从空间代价上看， 归并排序不如快速排序
 *  稳定性:
 *      快速排序是不稳定的，而归并排序是稳定的。 在这方面，这两个排序完全不同。如果稳定性没有要求，则两者差别不大；但如果对稳定性有要求，则快速排序则不适用。所以归并排序在这方面有一个比较大的优势。
 *  时间代价:
 *      从时间代价上看， 两个算法评分秋色。 但理论分析并不等于实际运行结果。 不同的编译器可能对不同的算法有不同的执行效率。这个不在这里介绍了。
 * 
 *  题外话:
 *  快速排序的性能
 *  快速排序的运行时间与划分是否对称有关，而对称与否是与选择的哪个具体元素来划分有关的。如果划分对称，那么快速排序从渐进意义上来讲， 就与合并算法一样快； 如果划分是不对称的，那么快速排序渐进上就和插入算法一样慢。
 */